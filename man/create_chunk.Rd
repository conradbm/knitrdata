% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_chunks.R
\name{create_chunk}
\alias{create_chunk}
\alias{insert_chunk}
\title{Tools for creating (data) chunks and inserting them into Rmarkdown documents}
\usage{
create_chunk(
  text = paste(readLines(file), collapse = "\\n"),
  ...,
  chunk_label = NULL,
  chunk_type = "data",
  file = NULL,
  chunk_options_string = NULL
)

insert_chunk(
  chunk,
  input.file,
  line,
  output.file = input.file,
  overwrite = input.file == output.file
)
}
\arguments{
\item{text}{Character vector with contents of chunk.}

\item{\dots}{Additional chunk options. These are not evaluated, but rather included
in the function call as they are entered in the function call.}

\item{chunk_label}{Character string giving the label to be used for the chunk.}

\item{chunk_type}{Character string giving the chunk type. Defaults to \code{"data"}.}

\item{file}{Path to file containing chunk contents. Ignored if \code{text}
argument supplied. As a consequence, this means that all arguments must be named
if the \code{file} argument is supplied to \code{create_chunk}.}

\item{chunk_options_string}{Character vector with text of chunk options. If given,
additional function arguments (\dots) will be ignored with a warning if any exist.}

\item{chunk}{Character string with chunk contents including header and tail.}

\item{input.file}{Rmarkdown file where chunk contents are to be inserted.}

\item{line}{Line number where chunk to be inserted.}

\item{output.file}{Where to write final Rmarkdown document with chunk spliced in.
Defaults to \code{input.file}.}

\item{overwrite}{Whether or not to overwrite the \code{output.file}. Defaults to
\code{TRUE} if \code{input.file=output.file}, otherwise \code{FALSE}.}
}
\description{
These helper functions allow one to add the chunk header and tail to text containing
chunk contents and then insert that into a Rmarkdown document.
}
\details{
\code{create_chunk}
takes in the (possibly encoded by \code{data_encode})
contents of a chunk and adds the chunk header and closer, invisibly returning
entire chunk contents as a character string.

\code{insert_chunk} takes the chunk contents and inserts it at the given line number
in the \code{input.file}. By default, it will overwrite \code{input.file} unless the
\code{output.file} argument is supplied and is different from \code{input.file}.

Note that the additional arguments to \code{create_chunk} (\dots) are not
evaluated, but rather they are placed in the chunk header as they appear in the
function call as additional chunk options.
}
\section{Functions}{
\itemize{
\item \code{create_chunk}: Silently returns chunk text contents.

\item \code{insert_chunk}: Inserts chunk contents into a Rmarkdown file
at the specified line number.
}}

\examples{
library(knitrdata)
library(tidyr) # For pipe operator

# Create new Rmarkdown document
if (file.exists("test.create_chunks.Rmd"))
  file.remove("test.create_chunks.Rmd")
rmarkdown::draft("test.create_chunks.Rmd","github_document","rmarkdown",
                 edit=FALSE)

# Create some binary data
x = data.frame(a=1:10,b=(1:10)^2)
saveRDS(x,"test.create_chunks.RDS")

# Push chunks into Rmarkdown document
# Insert in reverse order to not have to figure out line number
create_chunk("plot(b~a,data=x)",chunk_type="r") \%>\%
  insert_chunk("test.create_chunks.Rmd",11)
data_encode("test.create_chunks.RDS","base64") \%>\%
  create_chunk(output.var="x",format="binary",loader.function=readRDS) \%>\%
  insert_chunk("test.create_chunks.Rmd",11)
create_chunk("library(knitrdata)",chunk_type="r") \%>\%
  insert_chunk("test.create_chunks.Rmd",11)

# Render document to test
rmarkdown::render("test.create_chunks.Rmd")

# Clean up
file.remove("test.create_chunks.Rmd","test.create_chunks.RDS",
            "test.create_chunks.md","test.create_chunks.html")
}
\author{
David M. Kaplan \email{dmkaplan2000@gmail.com}
}
\concept{create_chunks}
